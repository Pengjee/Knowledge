# 字节跳动面试清单

## 基础知识

### 原型链
原型（prototype）指的就是一个对象，实例“继承”那个对象的属性。在原型上定义的属性，通过“继承”，实例也拥有了这个属性。“继承”这个行为是在new操作符内部实现的。
```js
function Person () {}

Person.prototype // Person原型
```
当有个构造函数的时候，我们就可以在原型上创建可以“继承”的属性，并通过new操作符创建实例，比如我们有一个Person，我们要创建一个person实例，那么使用new操作符就可以实现，并通过instanceof来检查：
```js
function Person () {}
const person = new Person()
console.log(person instanceof Person) // true
```
当我们在原型上定义了一个属性，那么在构造函数在被实例化后，这个属性也会被“继承”下来：
```js
function Person () {}
Person.prototype.name = 'pjee'
const person = new Person()
console.log(person.name) // pjee
```
当我们想要通过实例去访问原型时，这时我们就需要依靠`__proto__`隐式原型，所以如果是实例，那么就可以通过这个属性直接访问到原型：
```js
function Person() {}
Person.prototype.name = 'pjee'
const person = new Person()
console.log(person.__proto__ === Person.prototype) // true
```
那么既然构造函数通过prototype来访问到原型，那么原型是可以通过某种途径访问到构造函数的，这个是constructor:
```js
function Person () {}
Person.prototype.name = 'pjee'
person = new Person()
console.log(person.prototype.constructor === Person) //true
```
那么构造函数、实例化函数、原型就有下面这么一个关系：
![avatar](https://user-gold-cdn.xitu.io/2019/3/14/1697caac2a745a9e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  
这个这里的constructor是原型的一个属性，Constructor指的才是真正的构造函数。名字一定不要弄混了。

那么有没有从实例直接访问到构造函数的属性或者方法，实例与原型可以通过`__proto__`去访问到。当在读取一个实例的属性的过程中，如果属性在该实例中没有找到，那么就会冲`__proto__`指定的原型去寻找，如果还没有，那么就会一层一层的往下继续寻找。
```js
function Person () {}
Person.prototype.name = 'pjee'
const person = new Person()
let res = Reflect.ownKeys(person) // 尝试获取到自有属性
```
原型同样可以通过`__proto__`访问到原型的原型，比方说有一个构造函数Person，然后“继承”前者的有一个构造函数People，然后new People得到实例p。  
当访问p中的一个非自有属性的时候，就会通过`__proto__`作为桥梁连接起来的一系列原型、原型的原型...知道Object构造函数为止。
```js
function Person () {}
Person.prototype.name = 'pjee'
function People () {}
People.prototype = new Person()
const p = new People()
const res = [p instanceof Object, p instanceof Person, p instanceof People] // true true true
console.log(p.name) // pjee
```
![avatar](https://user-gold-cdn.xitu.io/2019/3/14/1697caac6f1e804c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)    
当原型链检索到null为止，搜不到那访问的这个属性就是不存在的：
```js
function Person() {}
Person.prototype.name = 'pjee'
function People () {}
People.prototype = new Person()
const p = new People()

console.log(p.__proto__) // Person {}
console.log(p.__proto__.__proto__) // Person { name: 'pjee' }
console.log(p.__proto__.__proto__.__proto__) // {}
```
### this指向
![avatar](https://user-gold-cdn.xitu.io/2019/9/12/16d248eee996d61e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)    
### new操作符
```
/*
* @params constructor 一个指定对象实例的类或函数
* @params arguments 一个用于被constructor调用的参数列表
*/
new constructor[([arguments])]
```
当我在使用`new`关键字会进行如下的操作：
1. 创建一个空的简单Javascript对象（即`{}`）
2. 链接该对象（设置该对象的`constructor`）到另一个对象
3. 将步骤1新创建的对象作为`this`的上下文
4. 如果该函数没有返回对象，则返回`this`
我们把上面的步骤转为代码就是
```js
function _new (ctor) {
    if (typeof )
    let o = Object.create(obj.prototype)
    let args = [...arguments].slice(1)
    const res = o.apply(args)
    return res instanceof Object ? res : obj
}
```
### 隐式转换
原始类型：`Undefined`，`Null`，`String`，`Boolean`，`Number`  
引用类型：`Array`，`Function`，`Math`，`Date`，`JSON`，`RegExp` 

valueOf / toString
```
// valueOf
({ a: 1 }).valueOf() // 原始值
('pjee').valueOf() // 原始值
```
### 事件循环机制

### 基础类型

### 数据去重/交并补

### 变量声明提升

### 函数作用域

### 节流/防抖

### apply/call

### jsonp跨域请求

### cors

### 箭头函数

### promise

### async/await

## 框架进阶

### Vue源码

### Vuex解析

### 双向绑定实现

### Vue组件通信方式

### React源码

### React redux

## 算法

### 冒泡、快排

### 二叉树遍历

### 大数相乘

## 网络相关

### http

### tcp/udp

### cookie/session

### jwt