# 一面

## 自我介绍

简单说了一下我任职过哪些公司，做了什么项目，技术栈有哪些

## 项目经历

问得非常非常非常的仔细，几乎每句话都在提问，所以要对自己写的项目经历不管是技术还是业务了解得深入才行。可以回答在做项目时用了什么技术，遇到了什么问题，怎么解决这些问题的...

## 八股文

下面这些问题也在问项目的时候，衍生出的问题

### 性能优化

- 非页面初始化时的必要请求全部后置
- 大图片等资源文件可上OSS，CDN
- 使用React.memo lazy等懒加载方式
- 打包时可通过配置webpack 代码切割，代码按需加载
- 在移动端可以提取react等不常更新的包，打成dll先提前内置近宿主
- 开启Nginx的Gzip
- 把前端资源发布至CDN
- 开启浏览器缓存（强缓存、协商缓存）
- 在页面加载资源时，渲染时，最好能提前给用户呈现一个loading效果或者骨架屏，然后用户感官上觉得页面已经在加载中了。

### 微前端（无界、iframe、qiankun）
#### 无界

无界微前端是腾讯推出的一款基于`WebComponent`、`iframe`

**CSS沙箱隔离**  
无界将子应用的dom放置在WebComponent + shadowdom的容器中，除了可继承的css属性外实现了应用之间的css原生隔离

**js沙箱隔离**  
无界将子应用的js放置在iframe中运行，实现了应用之间window、document、location、history的完全解耦和隔离。

**js沙箱和CSS沙箱链接**  
无界在底层采用Proxy + Object.defineProperty的方式将iframe中对dom操作劫持代理到WebComponent shadowRoot容器中。

#### qiankun

基于single-spa的一款微前端方案，采用过三种js沙箱方式：

- SnapshotSandbox：通过遍历window上的属性，然后全部挂在另一个自定义window，但是这种方式性能差。
```js
function active() {
    for (const prop in window) {
        this.windowSnapshot[prop] = window[prop];
    }
    Object.keys(this.modifyPropsMap).forEach(prop => {
        window[prop] = this.modifyPropsMap[prop];
    });
}
```
- LegacySandbox：通过监听来直接记录 Diff 内容，Proxy可以比较良好的解决这个问题，这就诞生了LegacySandbox，可以实现和快照沙箱一样的功能，但是却性能更好，和SnapshotSandbox一样，由于会污染全局的window，LegacySandbox也仅仅允许页面同时运行一个微应用
```js
function active() {
    this.proxyWindow = new Proxy(fakeWindow, {
        set: (target, prop, value, receiver) => {
            const originalVal = window[prop];
            if (!window.hasOwnProperty(prop)) {
                this.addedPropsMapInSandbox.set(prop, value);
            } else if (!this.modifiedPropsOriginalValueMapInSandbox.has(prop)) {
                this.modifiedPropsOriginalValueMapInSandbox.set(prop, originalVal);
            }
            this.currentUpdatedPropsValueMap.set(prop, value);
            window[prop] = value;
        },
        get: (target, prop, receiver) => {
            return target[prop];
        }
    });
}
```
- ProxySandbox：ProxySandbox，完全不存在状态恢复的逻辑，同时也不需要记录属性值的变化，因为所有的变化都是沙箱内部的变化，和window没有关系，window上的属性自始至终都没有受到过影响
```js
function active () {
   const fakeWindow = Object.create(null);
   this.proxyWindow = new Proxy(fakeWindow,{
      set:(target, prop, value, receiver)=>{
         if(this.isRunning){
            target[prop] = value;
         }
      },
      get:(target, prop, receiver)=>{
         return  prop in target ? target[prop] : window[prop];
      }
   });
}
```
**优点**

1. html entry 的方式引入子应用，相比 js entry 极大的降低了应用改造的成本；
2. 完备的沙箱方案，js 沙箱做了 SnapshotSandbox、LegacySandbox、ProxySandbox 三套渐进增强方案，css 沙箱做了
   strictStyleIsolation、experimentalStyleIsolation 两套适用不同场景的方案；
3. 做了静态资源预加载能力；

**缺点**

1. 适配成本比较高，工程化、生命周期、静态资源路径、路由等都要做一系列的适配工作；
2. css 沙箱采用严格隔离会有各种问题，js 沙箱在某些场景下执行性能下降严重；
3. 无法同时激活多个子应用，也不支持子应用保活；
4. 无法支持 vite 等 esmodule 脚本运行；

### React Fiber原理

### React Hooks原理

### 宏任务与微任务

### 旋转链表

## 二面

### CRM营销项目

### 前端性能优化

### CDN

### 原型链

### H5和小程序的区别，小程序有哪些优缺点
#### 区别
1. 环境：h5是运行在浏览器当中，小程序是运行在自己的app内部环境中。
2. 加载渲染：h5是通过浏览器加载资源、渲染页面；小程序是微信内的云端应用（无需安装），通过WebSocket双向通信、本地缓存以及微信底层技术优化实现了接近原生APP 的体验。
3. 原生能力：h5调用原生的相机、通讯录等能力的时候只能通过jsbridge的方式，而小程序依赖于原生，直接完成的了这部分的对接，调用对应api即可跟家方便。
4. 发布：h5随时都能发布，不受宿主的管控，小程序的发布需要依赖宿主的审核
5. 安全：小程序是直接对接app原，所有请求也是通过原生发起，整个信息的安全性都有爆炸。h5则可通过浏览器控制台等方式查看请求、响应信息等。

#### 小程序优点
1. 在针对支付等场景的时候，小程序的内部api调用更具安全性
2. 用户信息的获取，小程序能通过于原生直接交互，获取用户的基本信息